---
gssproxy:
  debug_level: 3
  services:
    # NOTE: service drop file names need to start with two digits and dash for
    # gssproxy to accept them
    50-jupyter:
      configFile: "files/gssproxy/jupyter.conf"
      # object needs to be granted delegation to any protocol in AD
      keytabFile: "files/gssproxy/jupyter.keytab"

jupyter:
  krb5ConfigFile: "files/krb5.conf"

daskhub:
  jupyterhub:
    proxy:
      secretToken: "88c3c97ba7e69593b661f4bb0ba3f28395c81dd8297ae859d3d39c81bdc982a1"
  #    chp:
  #      extraCommandLineFlags:
  #      - --log-level=debug
    singleuser:
      image:
        # s3fs
        name: mwa4/base-notebook
        tag: 21
        # alternatively with conda krb5, needs gssproxy:1.0.12-fedora below for now:
        #tag: 20-conda-krb5
      extraEnv:
        GSS_USE_PROXY: "yes"
        GSSPROXY_SOCKET: "/run/gssproxy/jupyter.sock"
      storage:
        extraVolumeMounts:
        - name: krb5-config
          mountPath: "/etc/krb5.conf"
          subPath: "krb5.conf"
          readOnly: true
        - name: gssproxy-sockets
          mountPath: /run/gssproxy
        extraVolumes:
        - name: krb5-config
          configMap:
            name: krb5-config
        - name: gssproxy-configs
          configMap:
            name: gssproxy-configs
        - name: gssproxy-keytabs
          secret:
            secretName: gssproxy-keytabs
        - name: gssproxy-sockets
          emptyDir: {}
      extraContainers:
      - name: gssproxy
        image: mwa4/gssproxy:1.0.12
        #image: mwa4/gssproxy:1.0.12-fedora
        volumeMounts:
        - name: krb5-config
          mountPath: "/etc/krb5.conf"
          subPath: "krb5.conf"
          readOnly: true
        - name: gssproxy-sockets
          mountPath: /run/gssproxy
        - name: gssproxy-configs
          mountPath: /etc/gssproxy
          readOnly: true
        - name: gssproxy-keytabs
          mountPath: /secrets/keytabs
          readOnly: true
      # stolen from https://gitlab.com/gitlab-org/gitlab-foss/-/blob/master/vendor/jupyter/values.yaml
      lifecycleHooks:
        postStart:
          exec:
            command:
              - "sh"
              - "-c"
              # the git credentials secret must be mounted without subPath to
              # get atomic updates. Therefore we need to point to the right
              # subPath using a symlink ourselves.
              - >
                git config --global credential.helper store;
                [ -L /home/jovyan/.config/jupyter/git-credentials/git-credentials ] && ln -sfn /home/jovyan/.config/jupyter/git-credentials/git-credentials /home/jovyan/.git-credentials;
                [ -z "${USER_EMAIL}" ] || git config --global user.email "${USER_EMAIL}";
                [ -z "${USER_REAL_NAME}" ] || git config --global user.name "${USER_REAL_NAME}";

    hub:
      config:
        Authenticator:
          allowed_users:
          - oauthuser
          - admin
          admin_users:
          - admin
      image:
        # boto3
        name: mwa4/k8s-hub
        tag: 1.0.1-boto3
      # prevent timeouts on callbacks from dask gateway into jupyterhub because
      # of active network policy
      # https://github.com/dask/helm-chart/issues/142
      networkPolicy:
        enabled: false
      services:
        dask-gateway:
          apiToken: "77a50bc4cac5e26c0a6423748318e37f1db2416476abb9733de58508781f8e72"
      extraEnv:
        OAUTH_CALLBACK_URL: "http://192.168.122.90/hub/oauth_callback"
        OAUTH2_AUTHORIZE_URL: "http://192.168.122.91/auth/realms/example.org/protocol/openid-connect/auth"
        OAUTH2_TOKEN_URL: "http://192.168.122.91/auth/realms/example.org/protocol/openid-connect/token"
        # adjust! openssl rand -hex 32
        JUPYTERHUB_CRYPT_KEY: "114903f5d652fe7e3cc3fe51e3e60f4899a6ddc18b891cfbed68e294f40085cf"
      extraConfig:
        oauth2.py: |
          from tornado.auth import OAuth2Mixin
          from tornado.httputil import url_concat
          from tornado.httpclient import HTTPRequest
          from jupyterhub.handlers import BaseHandler
          from jupyterhub.utils import url_path_join
          from oauthenticator.generic import GenericOAuthenticator
          from oauthenticator.oauth2 import OAuthCallbackHandler, \
              _serialize_state, _deserialize_state
          from kubernetes.client.models import V1Secret, V1ObjectMeta
          from kubernetes.client.rest import ApiException
          from kubernetes.client import V1DeleteOptions
          import boto3
          import base64
          import uuid
          import secrets
          import hashlib

          # enable persisting auth state for refresh of tokens and transporting service tokens
          c.Authenticator.enable_auth_state = True
          c.Authenticator.refresh_pre_spawn = True
          # very aggressive refresh setting for testing, updates are only
          # done on non-api requests, though
          c.Authenticator.auth_refresh_age = 30

          # jupyter hub auth flow:
          # /oauth_login -> IDP -> /oauth_callback -> /hub -> /hub/spawn -> ...
          #
          # we add:
          # /oauth_login -> IDP -> /oauth_callback -> /gitlab_creds -> Gitlab Service (+ potentially another IDP) -> /gitlab_creds_callback -> /hub -> /hub/spawn -> ...

          class ChainingOauthCallbackHandler(OAuthCallbackHandler):
              def get_next_url(self, user=None):
                  """ Redirect to a different URI to acquire additional creds for the user """
                  # put original authenticator next url into new state to
                  # preserve it across additional roundtrips to different
                  # services
                  state = dict(
                      state_id=uuid.uuid4().hex,
                      next_url=super().get_next_url(user),
                  )
                  params = dict(state=_serialize_state(state))
                  #return url_concat('/gitlab_creds', params)
                  return url_concat('/github_creds', params)

          gitlab_host = "gitlab.example.org"
          gitlab_base_uri = "https://%s" % gitlab_host
          gitlab_authorize_url = "%s/oauth/authorize" % gitlab_base_uri
          gitlab_token_uri = "%s/oauth/token" % gitlab_base_uri
          gitlab_client_id = "7c64d5c2025a449619ccf262ac0af2642b074021c4097e270423b731858f9acd"
          gitlab_client_secret = "f9d43f080ec0c44e61e332bc7b8fd377178090f251fe5b44480532e56b65e583"
          gitlab_redirect_path = "gitlab_creds_callback"

          class GitlabCredsHandler(OAuth2Mixin, BaseHandler):
              _OAUTH_AUTHORIZE_URL = gitlab_authorize_url

              async def get(self):
                  redirect_uri= "%s://%s%s" % (self.request.protocol, self.request.host,
                     url_path_join(self.hub.server.base_url, gitlab_redirect_path))

                  # PKCE bits stolen from https://github.com/RomeoDespres/pkce/blob/master/pkce/__init__.py
                  code_verifier = secrets.token_urlsafe(96)
                  hashed = hashlib.sha256(code_verifier.encode('ascii')).digest()
                  encoded = base64.urlsafe_b64encode(hashed)
                  code_challenge = encoded.decode('ascii')[:-1]

                  # use auth state to transport code verifier to callback handler
                  auth_state = await self.current_user.get_auth_state()
                  auth_state['gitlab_code_verifier'] = code_verifier
                  await self.current_user.save_auth_state(auth_state)

                  # do not leak extra params intended for our IDP
                  #extra_params = self.authenticator.extra_authorize_params.copy()
                  self.log.info('Gitlab OAuth redirect: %r', redirect_uri)
                  # but do copy state to propagate it to final redirect
                  state = self.get_argument('state')
                  extra_params = dict(
                      state=state,
                      code_challenge=code_challenge,
                      code_challenge_method='S256',
                  )
                  self.authorize_redirect(
                      redirect_uri=redirect_uri,
                      client_id=gitlab_client_id,
                      scope=['read_repository', 'write_repository', 'api'],
                      extra_params=extra_params,
                      response_type='code',
                  )

          class GitlabCredsCallbackHandler(BaseHandler):
              async def get(self):
                  # stolen from GitlabOAuthenticator but without authentication part
                  code = self.get_argument("code")
                  redirect_uri= "%s://%s%s" % (self.request.protocol, self.request.host,
                     url_path_join(self.hub.server.base_url, gitlab_redirect_path))

                  auth_state = await self.current_user.get_auth_state()
                  code_verifier = auth_state.get('gitlab_code_verifier')

                  params = dict(
                      client_id=gitlab_client_id,
                      client_secret=gitlab_client_secret,
                      code=code,
                      code_verifier=code_verifier,
                      grant_type="authorization_code",
                      redirect_uri=redirect_uri,
                  )

                  url = url_concat(gitlab_token_uri, params)

                  req = HTTPRequest(
                      url,
                      method="POST",
                      headers={"Accept": "application/json"},
                      validate_cert=True,
                      body='',  # Body is required for a POST...
                  )

                  resp_json = await self.authenticator.fetch(req, label="getting access token")

                  # remember access and refresh tokens in auth state
                  auth_state = await self.current_user.get_auth_state()
                  auth_state['gitlab_access_token'] = resp_json.get('access_token')
                  auth_state['gitlab_refresh_token'] = resp_json.get('refresh_token')
                  await self.current_user.save_auth_state(auth_state)

                  state = self.get_argument('state')
                  next_url = _deserialize_state(state).get('next_url')
                  if not next_url:
                      next_url = url_path_join(self.hub.server.base_url, 'home')
                  self.redirect(next_url)

          github_host = "github.com"
          github_base_uri = "https://%s" % github_host
          github_authorize_url = "%s/login/oauth/authorize" % github_base_uri
          github_token_uri = "%s/login/oauth/access_token" % github_base_uri
          # differences between Github and OAuth apps for our use-case:
          # - only Github apps support PKCE
          # - only Github apps receive refresh tokens, access tokens for OAuth
          #   apps remain valid until explicitly revoked sideband!
          # - HTTPS URL for cloning is different: Github apps use username
          #   x-access-token and the access token as password while OAuth apps
          #   use the token as username.
          # - Github apps must use an installation access token for git clone
          # - conclusion: Github apps have the more desireable and complete
          #   featureset OAuth2-wise but also restrictions tailored towards
          #   custom apps rather than developer access.
          github_client_id = "<id>"
          github_client_secret = "<secret>"
          #github_client_id = "<id>"
          #github_client_secret = "<secret>"
          github_redirect_path = "github_creds_callback"

          class GithubCredsHandler(OAuth2Mixin, BaseHandler):
              _OAUTH_AUTHORIZE_URL = github_authorize_url

              async def get(self):
                  redirect_uri= "%s://%s%s" % (self.request.protocol, self.request.host,
                     url_path_join(self.hub.server.base_url, github_redirect_path))

                  # PKCE is not supported for OAuth2 apps, only Github Apps as of now

                  # PKCE bits stolen from https://github.com/RomeoDespres/pkce/blob/master/pkce/__init__.py
                  #code_verifier = secrets.token_urlsafe(96)
                  #hashed = hashlib.sha256(code_verifier.encode('ascii')).digest()
                  #encoded = base64.urlsafe_b64encode(hashed)
                  #code_challenge = encoded.decode('ascii')[:-1]

                  # use auth state to transport code verifier to callback handler
                  #auth_state = await self.current_user.get_auth_state()
                  #auth_state['github_code_verifier'] = code_verifier
                  #await self.current_user.save_auth_state(auth_state)

                  # do not leak extra params intended for our IDP
                  #extra_params = self.authenticator.extra_authorize_params.copy()
                  self.log.info('Gitlab OAuth redirect: %r', redirect_uri)
                  # but do copy state to propagate it to final redirect
                  state = self.get_argument('state')
                  extra_params = dict(
                      state=state,
                      #code_challenge=code_challenge,
                      #code_challenge_method='S256',
                  )
                  self.authorize_redirect(
                      redirect_uri=redirect_uri,
                      client_id=github_client_id,
                      scope=['repo'],
                      extra_params=extra_params,
                      response_type='code',
                  )

          class GithubCredsCallbackHandler(BaseHandler):
              async def get(self):
                  # stolen from GitHubOAuthenticator but without authentication part
                  code = self.get_argument("code")
                  redirect_uri= "%s://%s%s" % (self.request.protocol, self.request.host,
                     url_path_join(self.hub.server.base_url, github_redirect_path))

                  #auth_state = await self.current_user.get_auth_state()
                  #code_verifier = auth_state.get('github_code_verifier')

                  params = dict(
                      client_id=github_client_id,
                      client_secret=github_client_secret,
                      code=code,
                      #code_verifier=code_verifier,
                      grant_type="authorization_code",
                      redirect_uri=redirect_uri,
                  )

                  url = url_concat(github_token_uri, params)

                  req = HTTPRequest(
                      url,
                      method="POST",
                      headers={"Accept": "application/json"},
                      validate_cert=True,
                      body='',  # Body is required for a POST...
                  )

                  resp_json = await self.authenticator.fetch(req, label="getting access token")

                  # remember access and refresh tokens in auth state
                  auth_state = await self.current_user.get_auth_state()
                  auth_state['github_access_token'] = resp_json.get('access_token')
                  #auth_state['github_refresh_token'] = resp_json.get('refresh_token')
                  await self.current_user.save_auth_state(auth_state)

                  state = self.get_argument('state')
                  next_url = _deserialize_state(state).get('next_url')
                  if not next_url:
                      next_url = url_path_join(self.hub.server.base_url, 'home')
                  self.redirect(next_url)

          class KubeGenericOAuthenticator(GenericOAuthenticator):
              callback_handler = ChainingOauthCallbackHandler

              def get_handlers(self, app):
                  handlers = super().get_handlers(app)
                  handlers.extend((
                    (r'/gitlab_creds', GitlabCredsHandler),
                    (r'/gitlab_creds_callback', GitlabCredsCallbackHandler),
                    (r'/github_creds', GithubCredsHandler),
                    (r'/github_creds_callback', GithubCredsCallbackHandler),
                  ))
                  return handlers

              async def refresh_user(self, user, handler=None):
                  self.log.info('refresh user: %s', user.name)
                  auth_state = await user.get_auth_state()
                  gitlab_access_token = auth_state.get('gitlab_access_token')
                  gitlab_refresh_token = auth_state.get('gitlab_refresh_token')
                  if gitlab_access_token and gitlab_refresh_token:
                      params = dict(
                          grant_type="refresh_token",
                          refresh_token=gitlab_refresh_token,
                          client_id=gitlab_client_id,
                          client_secret=gitlab_client_secret,
                      )

                      url = url_concat(gitlab_token_uri, params)

                      req = HTTPRequest(
                          url,
                          method="POST",
                          headers={"Accept": "application/json"},
                          validate_cert=True,
                          body='',  # Body is required for a POST...
                      )

                      resp_json = await self.fetch(req, label="getting refreshed access token")
                      auth_state['gitlab_access_token'] = resp_json.get('access_token')
                      # gitlab uses doorkeeper and doorkeeper does refresh
                      # token rotation by default. So we get a new refresh
                      # token with each access token, invalidating the old
                      # refresh token. Nice!
                      auth_state['gitlab_refresh_token'] = resp_json.get('refresh_token')

                  github_access_token = auth_state.get('github_access_token')
                  github_refresh_token = auth_state.get('github_refresh_token')
                  if github_access_token and github_refresh_token:
                      params = dict(
                          grant_type="refresh_token",
                          refresh_token=github_refresh_token,
                          client_id=github_client_id,
                          client_secret=github_client_secret,
                      )

                      url = url_concat(github_token_uri, params)

                      req = HTTPRequest(
                          url,
                          method="POST",
                          headers={"Accept": "application/json"},
                          validate_cert=True,
                          body='',  # Body is required for a POST...
                      )

                      resp_json = await self.fetch(req, label="getting refreshed access token")
                      self.log.info("bar: %s", resp_json)
                      auth_state['github_access_token'] = resp_json.get('access_token')
                      auth_state['github_refresh_token'] = resp_json.get('refresh_token')

                  # update the secret
                  secret_name = "jupyter-git-secrets-%s" % user.escaped_name

                  git_credentials = ""
                  gitlab_access_token = auth_state.get('gitlab_access_token')
                  if gitlab_access_token:
                      gitlab_url = "https://oauth2:%s@%s" % (gitlab_access_token, gitlab_host)
                      git_credentials += "%s\n" % gitlab_url

                  github_access_token = auth_state.get('github_access_token')
                  if github_access_token:
                      # OAuth App
                      github_url = "https://%s:x-oauth-basic@%s" % (github_access_token, github_host)
                      # Github App
                      #github_url = "https://x-access-token:%s@%s" % (github_access_token, github_host)
                      git_credentials += "%s\n" % github_url

                  secret = V1Secret()
                  secret.kind = "Secret"
                  secret.api_version = "v1"
                  secret.metadata = V1ObjectMeta()
                  secret.metadata.name = secret_name
                  secret.data = {
                      'git-credentials': base64.encodebytes(git_credentials.encode('ascii')).decode('ascii'),
                  }

                  for server_name in user.spawners:
                      spawner = user.spawners[server_name]
                      try:
                          await spawner.asynchronize(
                              spawner.api.replace_namespaced_secret,
                              secret_name,
                              spawner.namespace,
                              secret)
                      except ApiException as e:
                          if e.status != 404:
                              raise

                          await spawner.asynchronize(
                              spawner.api.create_namespaced_secret,
                              spawner.namespace,
                              secret)

                      # we only have one secret for all notebooks for now
                      break

                  return {'auth_state': auth_state}

              async def pre_spawn_start(self, user, spawner):
                  self.log.info('Pre spawn start : %s', user.name)
                  auth_state = await user.get_auth_state()
                  access_token = auth_state['access_token']

                  real_name = auth_state.get('oauth_user', {}).get('name')
                  if real_name:
                      spawner.environment['USER_REAL_NAME'] = real_name

                  email = auth_state.get('oauth_user', {}).get('email')
                  if email:
                      spawner.environment['USER_EMAIL'] = email

                  sts_client = boto3.client(
                      'sts',
                      region_name='us-east-1',
                      use_ssl=False,
                      endpoint_url='http://192.168.122.92',
                  )

                  response = sts_client.assume_role_with_web_identity(
                      RoleArn='arn:aws:iam::123456789012:user/svc-internal-api',
                      RoleSessionName='test',
                      WebIdentityToken=access_token,
                      DurationSeconds=3600
                  )

                  access_key = response['Credentials']['AccessKeyId']
                  secret_key = response['Credentials']['SecretAccessKey']
                  session_token = response['Credentials']['SessionToken']

                  for c in spawner.extra_containers:
                      if c['name'] != "gssproxy":
                          continue

                      if 'env' not in c:
                          c['env'] = []

                      c['env'].append({
                          'name': 'GSSPROXY_CREATE_USERS',
                          'value': '%s=1000' % user.escaped_name})

                  secret_name = "jupyter-secrets-%s" % user.escaped_name

                  secret = V1Secret()
                  secret.kind = "Secret"
                  secret.api_version = "v1"
                  secret.metadata = V1ObjectMeta()
                  secret.metadata.name = secret_name
                  #secret.metadata.annotations = (annotations or {}).copy()
                  #secret.metadata.labels = (labels or {}).copy()
                  #secret.metadata.owner_references = owner_references

                  secret.data = {}
                  secret.data['AWS_ACCESS_KEY_ID'] = base64.encodebytes(access_key.encode('ascii')).decode('ascii')
                  secret.data['AWS_SECRET_ACCESS_KEY'] = base64.encodebytes(secret_key.encode('ascii')).decode('ascii')
                  secret.data['AWS_SESSION_TOKEN'] = base64.encodebytes(session_token.encode('ascii')).decode('ascii')

                  try:
                      await spawner.asynchronize(
                          spawner.api.delete_namespaced_secret,
                          name=secret_name,
                          namespace=spawner.namespace,
                          body=V1DeleteOptions())
                  except ApiException as e:
                      if e.status != 404:
                          raise

                  await spawner.asynchronize(
                      spawner.api.create_namespaced_secret,
                      spawner.namespace,
                      secret)

                  if 'envFrom' not in spawner.extra_container_config:
                      spawner.extra_container_config['envFrom'] = []

                  spawner.extra_container_config['envFrom'].append({
                          'secretRef': {
                              'name': secret_name,
                          }
                      })

                  gitlab_access_token = auth_state.get('gitlab_access_token')
                  github_access_token = auth_state.get('github_access_token')
                  if gitlab_access_token or github_access_token:
                      secret_name = "jupyter-git-secrets-%s" % user.escaped_name

                      # secret is created in refresh_user() before spawn as well

                      spawner.volumes.append({
                          'name': 'git-credentials',
                          'secret': {
                              'secretName': secret_name,
                          }})

                      spawner.volume_mounts.append({
                          'name': 'git-credentials',
                          'mountPath': '/home/jovyan/.config/jupyter/git-credentials',
                          })

              async def post_spawn_stop(self, user, spawner):
                  try:
                      await spawner.asynchronize(
                          spawner.api.delete_namespaced_secret,
                          name="jupyter-secrets-%s" % user.escaped_name,
                          namespace=spawner.namespace,
                          body=V1DeleteOptions())
                  except ApiException as e:
                      if e.status != 404:
                          raise

                  try:
                      await spawner.asynchronize(
                          spawner.api.delete_namespaced_secret,
                          name="jupyter-git-secrets-%s" % user.escaped_name,
                          namespace=spawner.namespace,
                          body=V1DeleteOptions())
                  except ApiException as e:
                      if e.status != 404:
                          raise

          c.JupyterHub.authenticator_class = KubeGenericOAuthenticator

          c.KubeGenericOAuthenticator.login_service = "keycloak"
          c.KubeGenericOAuthenticator.client_id = "jupyter"
          c.KubeGenericOAuthenticator.client_secret = "5f143785-8c14-4405-8281-e4318683223e"
          c.KubeGenericOAuthenticator.token_url = "http://192.168.122.91/auth/realms/example.org/protocol/openid-connect/token"
          c.KubeGenericOAuthenticator.userdata_url = "http://192.168.122.91/auth/realms/example.org/protocol/openid-connect/userinfo"
          c.KubeGenericOAuthenticator.userdata_method = 'GET'
          c.KubeGenericOAuthenticator.userdata_params = {'state': 'state'}
          c.KubeGenericOAuthenticator.username_key = 'preferred_username'

  dask-gateway:
  #  traefik:
  #    loglevel: DEBUG
  #     dashboard: true
    gateway:
  #    loglevel: DEBUG
      auth:
  #      type: jupyterhub
        jupyterhub:
          apiToken: "77a50bc4cac5e26c0a6423748318e37f1db2416476abb9733de58508781f8e72"
      extraConfig:
        user-credentials: |
          from dask_gateway_server.options import Options

          def options_handler(options, user):
              if 'envFrom' not in c.KubeClusterConfig.worker_extra_container_config:
                  c.KubeClusterConfig.worker_extra_container_config['envFrom'] = []

              c.KubeClusterConfig.worker_extra_container_config['envFrom'].append({
                      'secretRef': {
                          'name': "jupyter-secrets-%s" % user.name,
                      }
                  })

              for cont in c.KubeClusterConfig.worker_extra_pod_config['containers']:
                if cont['name'] != "gssproxy":
                  continue

                if 'env' not in cont:
                  cont['env'] = []

                cont['env'].append({
                  'name': 'GSSPROXY_CREATE_USERS',
                  'value': '%s=1000' % user.name})

              return {}

          c.Backend.cluster_options = Options(handler=options_handler)

      backend:
        image:
          # s3fs
          name: mwa4/dask-gateway
          tag: 8
        scheduler:
          cores:
            request: 0.1
            limit: 1
          memory:
            request: "100M"
            limit: "2G"
        worker:
          cores:
            request: 0.1
            limit: 1
          memory:
            request: "100M"
            limit: "2G"
          extraContainerConfig:
            env:
            - name: GSS_USE_PROXY
              value: "yes"
            - name: GSSPROXY_SOCKET
              value: "/run/gssproxy/jupyter.sock"
            volumeMounts:
            - name: krb5-config
              mountPath: "/etc/krb5.conf"
              subPath: "krb5.conf"
              readOnly: true
            - name: gssproxy-sockets
              mountPath: /run/gssproxy
          extraPodConfig:
            volumes:
            - name: krb5-config
              configMap:
                name: krb5-config
            - name: gssproxy-configs
              configMap:
                name: gssproxy-configs
            - name: gssproxy-keytabs
              secret:
                secretName: gssproxy-keytabs
            - name: gssproxy-sockets
              emptyDir: {}
            containers:
            - name: gssproxy
              image: mwa4/gssproxy:1.0.12
              volumeMounts:
              - name: krb5-config
                mountPath: "/etc/krb5.conf"
                subPath: "krb5.conf"
                readOnly: true
              - name: gssproxy-sockets
                mountPath: /run/gssproxy
              - name: gssproxy-configs
                mountPath: /etc/gssproxy
                readOnly: true
              - name: gssproxy-keytabs
                mountPath: /secrets/keytabs
                readOnly: true
